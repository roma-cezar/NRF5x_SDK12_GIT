/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.2' (BDS version 1.1.3139.0) */
#include "service_if.h"
#include <stdint.h>
#include "ble_bas.h" 
#include "ble_wlan.h" 
#include "ble_meter.h" 
#include "ble_clock.h" 
#include "SEGGER_RTT.h"
#include "FLASH.h"

ble_bas_t    m_bas; 
ble_wlan_t    m_wlan; 
ble_meter_t    m_meter; 
ble_clock_t    m_clock; 

extern bool hot_water_notify_flag;
extern bool cold_water_notify_flag;
extern bool wlan_update_flag;
extern uint8_t SSID[16];
extern uint8_t PSWD[16];
extern uint32_t counter1;
extern uint32_t counter2;
extern uint8_t hours;
extern uint8_t minutes;
extern uint8_t seconds;
extern uint8_t mills;

/**@brief Function for handling the Battery Service events.
 *
 * @details This function will be called for all Battery Service events which are passed to
 *          the application.
 *
 * @param[in]   p_battery_service   Battery Service structure.
 * @param[in]   p_evt   Event received from the Battery Service.
 */
static void on_bas_evt(ble_bas_t * p_bas, ble_bas_evt_t * p_evt)
{
    switch (p_evt->evt_type)
    { 
        case BLE_BAS_BATTERY_LEVEL_EVT_NOTIFICATION_ENABLED:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: BAS_BATTERY_LEVEL evt NOTIFICATION_ENABLED. \r\n");
            break;
        case BLE_BAS_BATTERY_LEVEL_EVT_NOTIFICATION_DISABLED:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: BAS_BATTERY_LEVEL evt NOTIFICATION_DISABLED. \r\n");
            break;
        case BLE_BAS_BATTERY_LEVEL_EVT_CCCD_WRITE:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: BAS_BATTERY_LEVEL evt CCCD_WRITE. \r\n");
            break; 
        default:
            // No implementation needed.
            break;
    }
}


/**@brief Function for handling the WLAN events.
 *
 * @details This function will be called for all WLAN events which are passed to
 *          the application.
 *
 * @param[in]   p_wlan   WLAN structure.
 * @param[in]   p_evt   Event received from the WLAN.
 */
static void on_wlan_evt(ble_wlan_t * p_wlan, ble_wlan_evt_t * p_evt)
{
    switch (p_evt->evt_type)
    { 
        case BLE_WLAN_SSID_EVT_WRITE:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: WLAN_SSID evt WRITE. \r\n");
						memset(SSID, 0 , 16);
						memcpy(SSID, p_evt->params.ssid.ssid.p_str, p_evt->params.ssid.ssid.length);
				
            break; 
        case BLE_WLAN_PASS_EVT_WRITE:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: WLAN_PASS evt WRITE. \r\n");
						memset(PSWD, 0 , 16);
						memcpy(PSWD, p_evt->params.pass.pass.p_str, p_evt->params.pass.pass.length);
            break; 
        case BLE_WLAN_ACTION_EVT_WRITE:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: WLAN_ACTION evt WRITE. \r\n");
						if(p_evt->params.action.action == 1)
						{
							wlan_update_flag = true;
						}
						else
						{
							wlan_update_flag = false;
						}
            break; 
        default:
            // No implementation needed.
            break;
    }
}


/**@brief Function for handling the METER events.
 *
 * @details This function will be called for all METER events which are passed to
 *          the application.
 *
 * @param[in]   p_meter   METER structure.
 * @param[in]   p_evt   Event received from the METER.
 */
static void on_meter_evt(ble_meter_t * p_meter, ble_meter_evt_t * p_evt)
{
    switch (p_evt->evt_type)
    { 
        case BLE_METER_HOT_EVT_NOTIFICATION_ENABLED:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_HOT evt NOTIFICATION_ENABLED. \r\n");
            break;
        case BLE_METER_HOT_EVT_NOTIFICATION_DISABLED:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_HOT evt NOTIFICATION_DISABLED. \r\n");
            break;
        case BLE_METER_HOT_EVT_CCCD_WRITE:
						hot_water_notify_flag=!hot_water_notify_flag;
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_HOT evt CCCD_WRITE. \r\n");
            break; 
        case BLE_METER_HOT_EVT_WRITE:
						counter1 = p_evt->params.hot.hot;
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_HOT evt WRITE. \r\n");
            break; 
        case BLE_METER_COLD_EVT_NOTIFICATION_ENABLED:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_COLD evt NOTIFICATION_ENABLED. \r\n");
            break;
        case BLE_METER_COLD_EVT_NOTIFICATION_DISABLED:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_COLD evt NOTIFICATION_DISABLED. \r\n");
            break;
        case BLE_METER_COLD_EVT_CCCD_WRITE:
						cold_water_notify_flag = !cold_water_notify_flag;
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_COLD evt CCCD_WRITE. \r\n");
            break; 
        case BLE_METER_COLD_EVT_WRITE:
						counter2 = p_evt->params.cold.cold;
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: METER_COLD evt WRITE. \r\n");
            break; 
        default:
            // No implementation needed.
            break;
    }
}


/**@brief Function for handling the CLOCK events.
 *
 * @details This function will be called for all CLOCK events which are passed to
 *          the application.
 *
 * @param[in]   p_clock   CLOCK structure.
 * @param[in]   p_evt   Event received from the CLOCK.
 */
static void on_clock_evt(ble_clock_t * p_clock, ble_clock_evt_t * p_evt)
{
    switch (p_evt->evt_type)
    { 
        case BLE_CLOCK_HOURS_EVT_WRITE:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: CLOCK_HOURS evt WRITE. \r\n");
						hours = p_evt->params.hours.hours;
            break; 
        case BLE_CLOCK_MINUTES_EVT_WRITE:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: CLOCK_MINUTES evt WRITE. \r\n");
						minutes = p_evt->params.minutes.minutes;
            break; 
        case BLE_CLOCK_SECONDS_EVT_WRITE:
            SEGGER_RTT_WriteString(0, "[Bluetooth_IF]: CLOCK_SECONDS evt WRITE. \r\n");
						seconds = p_evt->params.seconds.seconds;
						mills = 0;
            break; 
        default:
            // No implementation needed.
            break;
    }
}


/**@brief Function for initializing the Services generated by Bluetooth Developer Studio.
 *
 *
 * @return      NRF_SUCCESS on successful initialization of services, otherwise an error code.
 */
uint32_t bluetooth_init(void)
{
    uint32_t    err_code; 
    ble_bas_init_t    bas_init; 
    ble_wlan_init_t    wlan_init; 
    ble_meter_init_t    meter_init; 
    ble_clock_init_t    clock_init; 
    

    // Initialize Battery Service.
    memset(&bas_init, 0, sizeof(bas_init));

    bas_init.evt_handler = on_bas_evt; 
    bas_init.is_battery_level_notify_supported = true;
    memset(&bas_init.ble_bas_battery_level_initial_value.level,
           0x00,
           sizeof(bas_init.ble_bas_battery_level_initial_value.level));

    err_code = ble_bas_init(&m_bas, &bas_init);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Initialize WLAN.
    memset(&wlan_init, 0, sizeof(wlan_init));

    wlan_init.evt_handler = on_wlan_evt; 
    ble_srv_ascii_to_utf8(&wlan_init.ble_wlan_ssid_initial_value.ssid, "INITIAL VALUE"); 
    ble_srv_ascii_to_utf8(&wlan_init.ble_wlan_pass_initial_value.pass, "INITIAL VALUE"); 
    memset(&wlan_init.ble_wlan_action_initial_value.action,
           0x00,
           sizeof(wlan_init.ble_wlan_action_initial_value.action));

    err_code = ble_wlan_init(&m_wlan, &wlan_init);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Initialize METER.
    memset(&meter_init, 0, sizeof(meter_init));

    meter_init.evt_handler = on_meter_evt; 
    memset(&meter_init.ble_meter_hot_initial_value.hot,
           0x00,
           sizeof(meter_init.ble_meter_hot_initial_value.hot));
    memset(&meter_init.ble_meter_cold_initial_value.cold,
           0x00,
           sizeof(meter_init.ble_meter_cold_initial_value.cold));

    err_code = ble_meter_init(&m_meter, &meter_init);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Initialize CLOCK.
    memset(&clock_init, 0, sizeof(clock_init));

    clock_init.evt_handler = on_clock_evt; 
    memset(&clock_init.ble_clock_hours_initial_value.hours,
           0x00,
           sizeof(clock_init.ble_clock_hours_initial_value.hours));
    memset(&clock_init.ble_clock_minutes_initial_value.minutes,
           0x00,
           sizeof(clock_init.ble_clock_minutes_initial_value.minutes));
    memset(&clock_init.ble_clock_seconds_initial_value.seconds,
           0x00,
           sizeof(clock_init.ble_clock_seconds_initial_value.seconds));

    err_code = ble_clock_init(&m_clock, &clock_init);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    return NRF_SUCCESS;
}

/**@brief Function for handling the Application's BLE Stack events.
 *
 * @details Handles all events from the BLE stack of interest to all Bluetooth Developer Studio generated Services.
 *
 * @param[in]   p_ble_evt  Event received from the BLE stack.
 */
void bluetooth_on_ble_evt(ble_evt_t * p_ble_evt)
{ 
    ble_bas_on_ble_evt(&m_bas, p_ble_evt); 
    ble_wlan_on_ble_evt(&m_wlan, p_ble_evt); 
    ble_meter_on_ble_evt(&m_meter, p_ble_evt); 
    ble_clock_on_ble_evt(&m_clock, p_ble_evt); 
}
